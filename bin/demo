#!/usr/bin/env node

// jshint node: true
'use strict';

var path = require('path');
var url = require('url');
var hyd = require('hydrolysis');
var p5u = require('parse5-utils/parse5-utils.js');
var loader = new hyd.loader();
loader.addResolver(new hyd.fsResolver({}));

function isUniqueImport(importNode) {
  return Boolean(importNode.url);
}

var headFinder = p5u.predicates.hasTagName('head');
var bodyFinder = p5u.predicates.hasTagName('body');
var attrs = ['action', 'href', 'src', 'style', 'assetpath'];
var attrMatcher = p5u.predicates.OR.apply(null, attrs.map(function(attr) {
  return p5u.predicates.hasAttr(attr);
}));
var elementMatcher = p5u.predicates.AND(
  p5u.predicates.hasTagName('dom-module'),
  p5u.predicates.hasAttr('id'),
  p5u.predicates.NOT(
    p5u.predicates.hasAttr('assetpath')
  )
);
function reparent(newParent) {
  return function(node) {
    node.parentNode = newParent;
  };
}

// make two absolute urls relative to each other
function relativeTo(from, to) {
  var parsedFrom = url.parse(from);
  var parsedTo = url.parse(to);
  if (parsedFrom.protocol === parsedTo.protocol && parsedFrom.host === parsedTo.host) {
    var pathname = path.relative(path.dirname(parsedFrom.pathname), parsedTo.pathname);
    return url.format({
      pathname: pathname,
      search: parsedTo.search,
      hash: parsedTo.hash
    });
  }
  return to;
}

function remove(node) {
  var parent = node.parentNode;
  if (parent) {
    var idx = parent.childNodes.indexOf(node);
    if (idx > -1) {
      parent.childNodes.splice(idx, 1);
    }
  }
}

function flatten(tree) {
  var doc = tree.html.ast;
  var imports = tree.imports;
  var head = p5u.query(doc, headFinder);
  var body = p5u.query(doc, bodyFinder);
  var importNodes = tree.html.import;
  var importDoc, importHead, importBody, importHeadChildren, importBodyChildren;
  if (imports) {
    for (var i = 0, im; i < imports.length; i++) {
      im = imports[i];
      if (!isUniqueImport(im)) {
        remove(importNodes[i]);
        continue;
      }
      importDoc = flatten(im);
      importHead = p5u.query(importDoc, headFinder);
      importBody = p5u.query(importDoc, bodyFinder);
      // rewrite urls
      p5u.queryAll(importDoc, attrMatcher).forEach(function(node) {
        attrs.forEach(function(attr) {
          var attrValue = p5u.getAttribute(node, attr);
          if (attrValue) {
            var absUrl = url.resolve(im.url, attrValue);
            var relUrl = relativeTo(tree.url, absUrl);
            if (attr === 'assetpath') {
              relUrl += '/';
            }
            p5u.setAttribute(node, attr, relUrl);
          }
        });
      });
      p5u.queryAll(importDoc, elementMatcher).forEach(function(el) {
        var rel = relativeTo(tree.url, im.url);
        rel = path.dirname(rel) + '/';
        p5u.setAttribute(el, 'assetpath', rel);
      });
      // merge head and body tags for imports into main document
      importHeadChildren = importHead.childNodes;
      importBodyChildren = importBody.childNodes;
      importHeadChildren.forEach(reparent(head));
      importBodyChildren.forEach(reparent(body));
      // replace import node with importHeadChildren
      var idx = head.childNodes.indexOf(importNodes[i]);
      head.childNodes = [].concat(head.childNodes.slice(0, idx), importHeadChildren, head.childNodes.slice(idx + 1));
      // prepend import body to document body
      body.childNodes = importBodyChildren.concat(body.childNodes);
    }
  }
  return doc;
}

var target = process.argv[2];

if (!target) {
  console.error('no target!');
  process.exit(1);
}

loader.request(target).then(function(content) {
  return hyd.hydrolyze(content, true, target, loader);
}).then(function(tree) {
  var flatDoc = flatten(tree);
  var serializer = new (require('parse5').Serializer)();
  console.log(serializer.serialize(flatDoc));
}).catch(function(err) {
  console.log(err);
  process.exit(1);
});
