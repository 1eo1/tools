var WctSinon = (function () {
	'use strict';

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var extend = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var interfaceExtensions = [];
	/**
	 * Registers an extension that extends the global `Mocha` implementation
	 * with new helper methods. These helper methods will be added to the `window`
	 * when tests run for both BDD and TDD interfaces.
	 */
	function extendInterfaces(helperName, helperFactory) {
	    interfaceExtensions.push(function () {
	        var Mocha = window.Mocha;
	        // For all Mocha interfaces (probably just TDD and BDD):
	        Object.keys(Mocha.interfaces)
	            .forEach(function (interfaceName) {
	            // This is the original callback that defines the interface (TDD or
	            // BDD):
	            var originalInterface = Mocha.interfaces[interfaceName];
	            // This is the name of the "teardown" or "afterEach" property for the
	            // current interface:
	            var teardownProperty = interfaceName === 'tdd' ? 'teardown' : 'afterEach';
	            // The original callback is monkey patched with a new one that appends
	            // to the global context however we want it to:
	            Mocha.interfaces[interfaceName] = function (suite) {
	                // Call back to the original callback so that we get the base
	                // interface:
	                originalInterface.apply(this, arguments);
	                // Register a listener so that we can further extend the base
	                // interface:
	                suite.on('pre-require', function (context, _file, _mocha) {
	                    // Capture a bound reference to the teardown function as a
	                    // convenience:
	                    var teardown = context[teardownProperty].bind(context);
	                    // Add our new helper to the testing context. The helper is
	                    // generated by a factory method that receives the context,
	                    // the teardown function and the interface name and returns
	                    // the new method to be added to that context:
	                    context[helperName] =
	                        helperFactory(context, teardown, interfaceName);
	                });
	            };
	        });
	    });
	}
	exports.extendInterfaces = extendInterfaces;
	/**
	 * Applies any registered interface extensions. The extensions will be applied
	 * as many times as this function is called, so don't call it more than once.
	 */
	function applyExtensions() {
	    interfaceExtensions.forEach(function (applyExtension) {
	        applyExtension();
	    });
	}
	exports.applyExtensions = applyExtensions;

	});

	unwrapExports(extend);
	var extend_1 = extend.extendInterfaces;
	var extend_2 = extend.applyExtensions;

	var replace_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * replace
	 *
	 * The replace addon allows the tester to replace all usages of one element with
	 * another element within all Polymer elements created within the time span of
	 * the test. Usage example:
	 *
	 * beforeEach(function() {
	 *   replace('x-foo').with('x-fake-foo');
	 * });
	 *
	 * All annotations and attributes will be set on the placement element the way
	 * they were set for the original element.
	 */
	function replace(_context, teardown) {
	    return function replace(oldTagName) {
	        return {
	            with: function (tagName) {
	                // Standardizes our replacements map
	                oldTagName = oldTagName.toLowerCase();
	                tagName = tagName.toLowerCase();
	                replacements[oldTagName] = tagName;
	                // If the function is already a stub, restore it to original
	                if (document.importNode.isSinonProxy) {
	                    return;
	                }
	                var polymer = window['Polymer'];
	                if (polymer && !polymer.Element) {
	                    polymer.Element = function () { };
	                    polymer.Element.prototype._stampTemplate = function () { };
	                }
	                // Keep a reference to the original `document.importNode`
	                // implementation for later:
	                var originalImportNode = document.importNode;
	                // Use Sinon to stub `document.ImportNode`:
	                window['sinon']
	                    .stub(document, 'importNode', function (origContent, deep) {
	                    var templateClone = document.createElement('template');
	                    var content = templateClone.content;
	                    var inertDoc = content.ownerDocument;
	                    // imports node from inertDoc which holds inert nodes.
	                    templateClone.content.appendChild(inertDoc.importNode(origContent, true));
	                    // optional arguments are not optional on IE.
	                    var nodeIterator = document.createNodeIterator(content, NodeFilter.SHOW_ELEMENT, null, true);
	                    var node;
	                    // Traverses the tree. A recently-replaced node will be put
	                    // next, so if a node is replaced, it will be checked if it
	                    // needs to be replaced again.
	                    while (node = nodeIterator.nextNode()) {
	                        var currentTagName = node.tagName.toLowerCase();
	                        if (replacements.hasOwnProperty(currentTagName)) {
	                            currentTagName = replacements[currentTagName];
	                            // find the final tag name.
	                            while (replacements[currentTagName]) {
	                                currentTagName = replacements[currentTagName];
	                            }
	                            // Create a replacement:
	                            var replacement = document.createElement(currentTagName);
	                            // For all attributes in the original node..
	                            for (var index = 0; index < node.attributes.length; ++index) {
	                                // Set that attribute on the replacement:
	                                replacement.setAttribute(node.attributes[index].name, node.attributes[index].value);
	                            }
	                            // Replace the original node with the replacement node:
	                            node.parentNode.replaceChild(replacement, node);
	                        }
	                    }
	                    return originalImportNode.call(this, content, deep);
	                });
	                if (!replaceTeardownAttached) {
	                    // After each test...
	                    teardown(function () {
	                        replaceTeardownAttached = true;
	                        // Restore the stubbed version of `document.importNode`:
	                        var documentImportNode = document.importNode;
	                        if (documentImportNode.isSinonProxy) {
	                            documentImportNode.restore();
	                        }
	                        // Empty the replacement map
	                        replacements = {};
	                    });
	                }
	            }
	        };
	    };
	}
	exports.replace = replace;
	// replacement map stores what should be
	var replacements = {};
	var replaceTeardownAttached = false;

	});

	unwrapExports(replace_1);
	var replace_2 = replace_1.replace;

	var stub_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * stub
	 *
	 * The stub addon allows the tester to partially replace the implementation of
	 * an element with some custom implementation. Usage example:
	 *
	 * beforeEach(function() {
	 *   stub('x-foo', {
	 *     attached: function() {
	 *       // Custom implementation of the `attached` method of element `x-foo`..
	 *     },
	 *     otherMethod: function() {
	 *       // More custom implementation..
	 *     },
	 *     getterSetterProperty: {
	 *       get: function() {
	 *         // Custom getter implementation..
	 *       },
	 *       set: function() {
	 *         // Custom setter implementation..
	 *       }
	 *     },
	 *     // etc..
	 *   });
	 * });
	 */
	function stub(_context, teardown) {
	    return function stub(tagName, implementation) {
	        // Find the prototype of the element being stubbed:
	        var proto = document.createElement(tagName).constructor.prototype;
	        // For all keys in the implementation to stub with..
	        var stubs = Object.keys(implementation).map(function (key) {
	            // Stub the method on the element prototype with Sinon:
	            return window['sinon'].stub(proto, key, implementation[key]);
	        });
	        // After all tests..
	        teardown(function () {
	            stubs.forEach(function (stub) {
	                stub.restore();
	            });
	        });
	    };
	}
	exports.stub = stub;

	});

	unwrapExports(stub_1);
	var stub_2 = stub_1.stub;

	var browser = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	extend.extendInterfaces('replace', replace_1.replace);
	extend.extendInterfaces('stub', stub_1.stub);
	extend.applyExtensions();

	});

	var browser$1 = unwrapExports(browser);

	return browser$1;

}());
